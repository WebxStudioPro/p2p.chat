<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Global P2P Chat (Magnet Engine + Premium UX)</title>
    
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>

    <style>
        * { box-sizing: border-box; font-family: 'Segoe UI', Tahoma, sans-serif; margin: 0; }
        
        /* ðŸ”¥ THE VIEWPORT FIX: 100dvh prevents bottom bar hiding on Android/iOS ðŸ”¥ */
        body { background-color: #0d1117; color: #c9d1d9; display: flex; flex-direction: column; height: 100vh; height: 100dvh; overflow: hidden; }
        
        #header { padding: 15px; background: #161b22; text-align: center; border-bottom: 1px solid #30363d; box-shadow: 0 4px 6px rgba(0,0,0,0.3); z-index: 10; min-height: 70px; display: flex; align-items: center; justify-content: center; flex-shrink: 0;}
        
        #default-header { width: 100%; }
        #default-header h2 { color: #58a6ff; font-size: 20px; text-transform: uppercase; letter-spacing: 1px; }
        #status-bar { font-size: 13px; color: #8b949e; margin-top: 5px; font-weight: bold; }
        
        /* DYNAMIC HEADER (WITH TYPING INDICATOR) */
        #chat-header { display: none; width: 100%; align-items: center; justify-content: flex-start; gap: 12px; padding: 0 10px; }
        .avatar-circle { width: 40px; height: 40px; background: #30363d; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 20px; }
        .stranger-info-box { text-align: left; display: flex; flex-direction: column; }
        #top-stranger-name { font-size: 16px; font-weight: bold; color: white; }
        
        .badge-container { display: flex; align-items: center; gap: 8px; margin-top: 3px; }
        #top-stranger-gender { font-size: 11px; font-weight: bold; padding: 2px 8px; border-radius: 10px; display: inline-block; }
        .gender-male { background: #1f6feb; color: white; }
        .gender-female { background: #da3633; color: white; }
        
        /* Typing Indicator Style */
        #typing-indicator { font-size: 12px; color: #3fb950; font-weight: bold; display: none; font-style: italic; }
        
        /* PROFILE SETUP UI */
        #setup-container { flex: 1; display: flex; flex-direction: column; justify-content: center; padding: 20px; }
        .setup-box { background: #161b22; padding: 25px; border-radius: 12px; border: 1px solid #30363d; box-shadow: 0 10px 20px rgba(0,0,0,0.5); }
        .setup-box h3 { color: white; text-align: center; margin-bottom: 20px; font-size: 18px; }
        .input-group { margin-bottom: 15px; }
        .input-group label { display: block; color: #8b949e; margin-bottom: 5px; font-size: 13px; text-transform: uppercase; letter-spacing: 0.5px;}
        .profile-input { width: 100%; padding: 12px; border-radius: 8px; border: 1px solid #30363d; background: #0d1117; color: white; outline: none; font-size: 15px; }
        #save-profile-btn { width: 100%; padding: 15px; border-radius: 8px; background: #238636; color: white; border: none; font-weight: bold; font-size: 16px; margin-top: 10px; transition: 0.2s; }
        
        /* CHAT UI */
        #chat-window { flex: 1; overflow-y: auto; padding: 15px; display: none; flex-direction: column; gap: 10px; }
        .message { padding: 12px 16px; border-radius: 18px; max-width: 85%; font-size: 15px; word-wrap: break-word; box-shadow: 0 2px 4px rgba(0,0,0,0.1); position: relative;}
        .my-message { background: #238636; color: white; align-self: flex-end; border-bottom-right-radius: 4px; }
        .stranger-message { background: #21262d; color: #c9d1d9; border: 1px solid #30363d; align-self: flex-start; border-bottom-left-radius: 4px; }
        .sender-name { font-size: 11px; color: #8b949e; margin-bottom: 4px; display: block; font-weight: bold; }
        .my-name { color: #85e89d; text-align: right; }
        
        .system-message { text-align: center; color: #8b949e; font-size: 13px; margin: 10px 0; font-style: italic; background: #21262d; padding: 8px; border-radius: 10px; }

        /* ACTION AREA LAYOUT FIX */
        #action-area { padding: 15px; background: #161b22; border-top: 1px solid #30363d; display: none; flex-shrink: 0; padding-bottom: max(15px, env(safe-area-inset-bottom)); }
        #find-btn { width: 100%; padding: 15px; border-radius: 8px; background: #1f6feb; color: white; border: none; font-weight: bold; font-size: 16px; transition: 0.2s; text-transform: uppercase; }
        
        #input-container { display: none; gap: 10px; align-items: center; width: 100%; }
        #msg-input { flex: 1; padding: 12px 15px; border-radius: 24px; border: 1px solid #30363d; background: #0d1117; color: white; outline: none; font-size: 15px; }
        #send-btn { padding: 12px 20px; border-radius: 24px; background: #238636; color: white; border: none; font-weight: bold; }
        #disconnect-btn { padding: 10px; border-radius: 50%; background: #da3633; color: white; border: none; font-weight: bold; width: 45px; height: 45px; display: flex; align-items: center; justify-content: center; font-size: 18px; flex-shrink: 0;}

        /* PREMIUM CUSTOM EXIT MODAL */
        #exit-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(3px); z-index: 100; display: none; align-items: center; justify-content: center; }
        .exit-modal-box { background: #161b22; width: 85%; max-width: 350px; border-radius: 16px; padding: 25px; text-align: center; border: 1px solid #30363d; box-shadow: 0 15px 30px rgba(0,0,0,0.8); animation: popIn 0.3s ease-out; }
        .exit-modal-box h3 { color: white; font-size: 18px; margin-bottom: 10px; }
        .exit-modal-box p { color: #8b949e; font-size: 14px; margin-bottom: 25px; line-height: 1.5; }
        .modal-buttons { display: flex; gap: 10px; }
        .btn-cancel { flex: 1; padding: 12px; border-radius: 8px; background: #21262d; color: white; border: 1px solid #30363d; font-weight: bold; font-size: 14px; }
        .btn-leave { flex: 1; padding: 12px; border-radius: 8px; background: #da3633; color: white; border: none; font-weight: bold; font-size: 14px; }
        
        @keyframes popIn { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    </style>
</head>
<body>

    <div id="header">
        <div id="default-header">
            <h2>Global Mesh</h2>
            <div id="status-bar">Profile Setup</div>
        </div>
        
        <div id="chat-header">
            <div class="avatar-circle">ðŸ‘¤</div>
            <div class="stranger-info-box">
                <span id="top-stranger-name">Searching...</span>
                <div class="badge-container">
                    <span id="top-stranger-gender" class="gender-male">Unknown</span>
                    <span id="typing-indicator">typing...</span>
                </div>
            </div>
        </div>
    </div>

    <div id="exit-modal-overlay">
        <div class="exit-modal-box">
            <h3>Exit Chat?</h3>
            <p>Are you sure you want to disconnect? This chat will be lost forever.</p>
            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeModal()">Cancel</button>
                <button class="btn-leave" onclick="confirmExit()">Leave Chat</button>
            </div>
        </div>
    </div>

    <div id="setup-container">
        <div class="setup-box">
            <h3>Create Your Identity</h3>
            <div class="input-group">
                <label>Nickname</label>
                <input type="text" id="user-name" class="profile-input" placeholder="Enter a cool name..." maxlength="15">
            </div>
            <div class="input-group">
                <label>Gender</label>
                <select id="user-gender" class="profile-input">
                    <option value="Male">Male</option>
                    <option value="Female">Female</option>
                </select>
            </div>
            <button id="save-profile-btn" onclick="saveProfile()">ENTER LOBBY</button>
        </div>
    </div>

    <div id="chat-window">
        <div class="system-message">Engine Online. Ready for Magnet Search.</div>
    </div>
    
    <div id="action-area">
        <button id="find-btn" onclick="initiateMatchmaking()">CONNECT TO STRANGER</button>
        <div id="input-container">
            <button id="disconnect-btn" onclick="showExitModal()">âœ–</button>
            <input type="text" id="msg-input" placeholder="Type a message..." oninput="handleTypingEvent()" onkeypress="handleKeypress(event)">
            <button id="send-btn" onclick="sendDataChannelMessage()">SEND</button>
        </div>
    </div>

    <script>
        const UI = {
            defaultHeader: document.getElementById('default-header'),
            chatHeader: document.getElementById('chat-header'),
            topName: document.getElementById('top-stranger-name'),
            topGender: document.getElementById('top-stranger-gender'),
            typingIndicator: document.getElementById('typing-indicator'),
            status: document.getElementById('status-bar'),
            setupContainer: document.getElementById('setup-container'),
            chatBox: document.getElementById('chat-window'),
            actionArea: document.getElementById('action-area'),
            findBtn: document.getElementById('find-btn'),
            inputArea: document.getElementById('input-container'),
            msgInput: document.getElementById('msg-input'),
            userNameInput: document.getElementById('user-name'),
            userGenderInput: document.getElementById('user-gender'),
            exitModal: document.getElementById('exit-modal-overlay')
        };

        let myProfile = { name: 'Stranger', gender: 'Unknown' };
        
        let typingTimer = null;
        let amITyping = false;

        // ðŸ”¥ THE V14 MAGNET ENGINE VARIABLES ðŸ”¥
        const GLOBAL_RADAR = 'krish_v14_global_magnet_radar'; 
        let mySessionId = 'peer_' + Math.random().toString(36).substr(2, 9);
        let PRIVATE_TOPIC = `krish_v14_private_${mySessionId}`;
        let radarInterval = null; // Timer to keep sending Magnet Pulses
        
        let mqttClient = null;
        let peerConnection = null;
        let dataChannel = null;
        let isSearching = false;

        const rtcConfiguration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun.cloudflare.com:3478' },
                { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },
                { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' }
            ]
        };

        function showExitModal() { UI.exitModal.style.display = 'flex'; }
        function closeModal() { UI.exitModal.style.display = 'none'; }
        function confirmExit() { closeModal(); terminateSession(); }

        function saveProfile() {
            let nameVal = UI.userNameInput.value.trim();
            if(nameVal === '') nameVal = 'Stranger';
            
            myProfile.name = nameVal;
            myProfile.gender = UI.userGenderInput.value;

            UI.setupContainer.style.display = 'none';
            UI.chatBox.style.display = 'flex';
            UI.actionArea.style.display = 'flex'; 
            
            connectSignalingServer();
        }

        function connectSignalingServer() {
            updateStatus('Connecting to Core Engine...', '#8b949e');
            mqttClient = mqtt.connect('wss://broker.emqx.io:8084/mqtt');

            mqttClient.on('connect', () => {
                updateStatus(`Welcome, ${myProfile.name}. Ready to search.`, '#3fb950');
                mqttClient.subscribe(PRIVATE_TOPIC); // Always listen on private frequency
            });

            mqttClient.on('message', async (topic, message) => {
                const payload = JSON.parse(message.toString());
                handleSignalingData(payload);
            });
            
            mqttClient.on('error', (err) => {
                updateStatus('Network Error. Reconnecting...', '#da3633');
            });
        }

        // ðŸ”¥ V14: START MAGNET RADAR ðŸ”¥
        function initiateMatchmaking() {
            if (!mqttClient || !mqttClient.connected) {
                alert("Server is still connecting. Please wait a second.");
                return;
            }

            isSearching = true;
            UI.findBtn.style.display = 'none';
            UI.chatBox.innerHTML = ''; 
            updateStatus('Scanning Magnet Radar...', '#d29922');
            printSystemMessage('Searching the global radar...');

            // Join the Global Radar Room
            mqttClient.subscribe(GLOBAL_RADAR);
            
            // Send the first tiny pull signal
            const pulse = JSON.stringify({ type: 'magnet_pulse', senderId: mySessionId });
            mqttClient.publish(GLOBAL_RADAR, pulse);

            // If alone, keep sending a tiny signal every 2 seconds
            clearInterval(radarInterval);
            radarInterval = setInterval(() => {
                if (isSearching) {
                    mqttClient.publish(GLOBAL_RADAR, pulse);
                }
            }, 2000);
        }

        // ðŸ”¥ V14: THE MAGNET PULL & PRIVATE OFFLOADING ðŸ”¥
        async function handleSignalingData(payload) {
            
            // 1. I am searching, and I detected someone's Magnet Pulse on the Radar.
            if (payload.type === 'magnet_pulse' && payload.senderId !== mySessionId && isSearching) {
                // Instantly reply to their PRIVATE frequency (Not the global radar)
                sendSignalingPayload(payload.senderId, { type: 'magnet_pull', senderId: mySessionId });
            }

            // 2. Someone responded to my pulse and pulled me!
            if (payload.type === 'magnet_pull' && payload.senderId !== mySessionId) {
                if (isSearching) {
                    // Lock my engine
                    isSearching = false; 
                    clearInterval(radarInterval); 
                    mqttClient.unsubscribe(GLOBAL_RADAR); // Leave radar to prevent bheed
                    
                    updateStatus('Magnet Locked! Linking securely...', '#58a6ff');
                    initializeWebRTC(payload.senderId);
                    
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    // Send heavy data Privately
                    sendSignalingPayload(payload.senderId, { type: 'rtc_offer', offer: offer, senderId: mySessionId });
                } else {
                    // I am already pulled by someone else! Send Busy.
                    sendSignalingPayload(payload.senderId, { type: 'peer_busy', senderId: mySessionId });
                }
            }

            // 3. I received their Private WebRTC Offer
            if (payload.type === 'rtc_offer' && payload.senderId !== mySessionId) {
                if (isSearching) {
                    isSearching = false; 
                    clearInterval(radarInterval); 
                    mqttClient.unsubscribe(GLOBAL_RADAR);
                    
                    updateStatus('Linking securely...', '#58a6ff');
                    initializeWebRTC(payload.senderId);
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(payload.offer));
                    
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    sendSignalingPayload(payload.senderId, { type: 'rtc_answer', answer: answer, senderId: mySessionId });
                } else {
                    sendSignalingPayload(payload.senderId, { type: 'peer_busy', senderId: mySessionId });
                }
            }

            if (payload.type === 'peer_busy') {
                terminateSession(false, "âš ï¸ Stranger got connected to someone else. Please click CONNECT TO STRANGER again.");
            }

            if (payload.type === 'rtc_answer') {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(payload.answer));
            }

            if (payload.type === 'ice_candidate') {
                try { await peerConnection.addIceCandidate(new RTCIceCandidate(payload.candidate)); } 
                catch (e) { console.error('ICE Error', e); }
            }
        }

        function initializeWebRTC(targetPeerId) {
            if (peerConnection) peerConnection.close(); 
            peerConnection = new RTCPeerConnection(rtcConfiguration);

            dataChannel = peerConnection.createDataChannel('chat_channel');
            setupDataChannelListeners(dataChannel);

            peerConnection.ondatachannel = (event) => {
                dataChannel = event.channel;
                setupDataChannelListeners(dataChannel);
            };

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    sendSignalingPayload(targetPeerId, { type: 'ice_candidate', candidate: event.candidate, senderId: mySessionId });
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                if (peerConnection.iceConnectionState === 'disconnected' || peerConnection.iceConnectionState === 'failed') {
                    terminateSession(true);
                }
            };
        }

        // Send all heavy data and handshakes to a direct Private Topic
        function sendSignalingPayload(targetId, payloadObj) {
            mqttClient.publish(`krish_v14_private_${targetId}`, JSON.stringify(payloadObj));
        }

        // --- METADATA & TYPING ENGINE LOGIC ---
        function setupDataChannelListeners(channel) {
            channel.onopen = () => {
                UI.inputArea.style.display = 'flex';
                const introPacket = JSON.stringify({ type: 'intro', profile: myProfile });
                dataChannel.send(introPacket);
            };

            channel.onmessage = (event) => { 
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.type === 'intro') {
                        UI.defaultHeader.style.display = 'none';
                        UI.chatHeader.style.display = 'flex';
                        UI.topName.innerText = data.profile.name;
                        UI.topGender.innerText = data.profile.gender;
                        
                        if(data.profile.gender === 'Female') {
                            UI.topGender.className = 'gender-female';
                        } else {
                            UI.topGender.className = 'gender-male';
                        }

                        printSystemMessage(`You are chatting securely with ${data.profile.name}. Say Hi!`);
                    } 
                    else if (data.type === 'chat') {
                        renderMessage(data.content, 'stranger');
                        UI.typingIndicator.style.display = 'none'; 
                    }
                    else if (data.type === 'typing') {
                        if (data.status === true) {
                            UI.typingIndicator.style.display = 'inline-block';
                        } else {
                            UI.typingIndicator.style.display = 'none';
                        }
                    }
                } catch(e) {
                    renderMessage(event.data, 'stranger');
                }
            };

            channel.onclose = () => terminateSession(true);
        }

        function handleTypingEvent() {
            if (!dataChannel || dataChannel.readyState !== 'open') return;

            if (!amITyping) {
                amITyping = true;
                dataChannel.send(JSON.stringify({ type: 'typing', status: true }));
            }

            clearTimeout(typingTimer);
            typingTimer = setTimeout(() => {
                amITyping = false;
                dataChannel.send(JSON.stringify({ type: 'typing', status: false }));
            }, 1500);
        }

        function sendDataChannelMessage() {
            const text = UI.msgInput.value.trim();
            if (text === '' || !dataChannel || dataChannel.readyState !== 'open') return;

            const msgPacket = JSON.stringify({ type: 'chat', content: text, profile: myProfile });
            dataChannel.send(msgPacket);
            
            amITyping = false;
            clearTimeout(typingTimer);
            dataChannel.send(JSON.stringify({ type: 'typing', status: false }));

            renderMessage(text, 'mine');
            UI.msgInput.value = '';
        }

        function renderMessage(text, type) {
            const wrapper = document.createElement('div');
            wrapper.className = `message ${type === 'mine' ? 'my-message' : 'stranger-message'}`;
            wrapper.innerText = text;
            UI.chatBox.appendChild(wrapper);
            UI.chatBox.scrollTop = UI.chatBox.scrollHeight;
        }

        function printSystemMessage(text) {
            const wrapper = document.createElement('div');
            wrapper.className = 'system-message';
            wrapper.innerText = text;
            UI.chatBox.appendChild(wrapper);
            UI.chatBox.scrollTop = UI.chatBox.scrollHeight;
        }

        function updateStatus(text, color) { UI.status.innerText = text; UI.status.style.color = color; }
        
        function handleKeypress(e) { 
            if (e.key === 'Enter') sendDataChannelMessage(); 
        }

        function terminateSession(isRemoteDisconnect = false, customMessage = null) {
            if (peerConnection) { peerConnection.close(); }
            peerConnection = null; 
            dataChannel = null; 
            isSearching = false;
            
            // Clean Intervals
            clearInterval(radarInterval); 
            clearTimeout(typingTimer);
            amITyping = false;
            
            mqttClient.unsubscribe(GLOBAL_RADAR); // Ensure we leave radar
            mqttClient.unsubscribe(PRIVATE_TOPIC);
            mySessionId = 'peer_' + Math.random().toString(36).substr(2, 9);
            PRIVATE_TOPIC = `krish_v14_private_${mySessionId}`;
            mqttClient.subscribe(PRIVATE_TOPIC);

            UI.chatHeader.style.display = 'none';
            UI.typingIndicator.style.display = 'none';
            UI.defaultHeader.style.display = 'block';

            UI.inputArea.style.display = 'none';
            UI.findBtn.style.display = 'block';
            updateStatus('Disconnected.', '#da3633');
            
            UI.chatBox.innerHTML = ''; 
            
            if (customMessage) {
                printSystemMessage(customMessage);
            } else {
                printSystemMessage(isRemoteDisconnect ? 'Stranger has disconnected. Memory cleared.' : 'You left the chat. Memory cleared.');
            }
        }
    </script>
</body>
</html>